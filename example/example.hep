@(push_constant)
vs_constants: #import(Vertex_Shader_Uniforms)

@(vertex_shader, link_name = "main")
vertex_main :: proc(
	a_position:   [3]f32 @ 0,
	a_normal:     [3]f32 @ 1,
	a_tex_coords: [2]f32 @ 2,
) -> (
	v_position:   [3]f32 @ 0,
	v_normal:     [3]f32 @ 1,
	v_tex_coords: [2]f32 @ 2,
) {
	v_position   = (vs_constants.model * [4]f32{a_position, 1}).xyz
	v_normal     = a_normal
	v_tex_coords = a_tex_coords

	$Position = vs_constants.proj * vs_constants.view * [4]f32{v_position, 1}
	return
}

/* FRAGMENT SHADER */

@(binding = 1)
texture: sampler[2][3]f32
@(binding = 2)
depth_texture: sampler[2]f32

SHADOW_PASS :: #config(SHADOW_PASS, false)

when !SHADOW_PASS {
	@(uniform, binding = 0)
	shadow_uniforms: #import(Shadow_Uniforms)
}

@(fragment_shader, link_name = "main")
fragment_main :: proc(
	v_position:   [3]f32 @ 0,
	v_normal:     [3]f32 @ 1,
	v_tex_coords: [2]f32 @ 2,
) -> (
	f_color: [3]f32 @ 0,
) {
	when !SHADOW_PASS {
		v_normal         := normalize(v_normal)

	    _shadow_position := shadow_uniforms.shadow_matrix * [4]f32{v_position, 1}
	    shadow_position  := (_shadow_position.xyz / _shadow_position.w) * 0.5 + 0.5
	    depth            := shadow_position.z
	    dx               := ddx(depth)
	    dy               := ddy(depth)
	    bias             := 0.001
	    shadow           := 0
	    if shadow_position.x >= 0 && shadow_position.x <= 1 && shadow_position.y >= 0 && shadow_position.y <= 1 {
	    	d := depth_texture[shadow_position.xy] * 0.5 + 0.5
	    	if (depth - bias > d) {
	    		shadow = i32(exp(log(1)))
	    	}
	    }

		e := #import(Some_Enum).A
		switch e {
		case .A:
		case .B:
		case .C:
		}

		v: [3]i32
		x := cross(v, v)

		lighting := max(dot(v_normal, shadow_uniforms.light_direction), 0)
		f_color   = lighting * f32(1 - shadow) * texture[v_tex_coords]
		return
	}
}

@(fragment_shader)
shadow_main :: proc(
	v_position:   [3]f32 @ 0,
	v_normal:     [3]f32 @ 1,
	v_tex_coords: [2]f32 @ 2,
) {
	
}

/* COMPUTE SHADER */

Particle :: #import(Particle)

@(push_constant)
compute_constants: struct {
	delta_time: f32,
}

@(readonly)
particles_in:  []Particle
particles_out: []Particle

@(compute_shader, local_size = {256, 1, 1})
simulate_particles :: proc() {
	index               := $GlobalInvocationId.x
	particle_in         := particles_in[index]
	particles_out[index] = {
		position = particle_in.position + particle_in.velocity * compute_constants.delta_time,
		velocity = particle_in.velocity,
		color    = particle_in.color,
	}
}
