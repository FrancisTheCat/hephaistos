Binding_Location :: #import(Binding_Location)

SHADOW_PASS :: #config(SHADOW_PASS, false)

/* VERTEX SHADER */

@(push_constant)
vs_constants: #import(Vertex_Shader_Uniforms)

when !SHADOW_PASS {
	@(uniform, binding = Binding_Location.Shadow_Uniforms)
	shadow_uniforms: #import(Shadow_Uniforms)
}

@(vertex_shader, link_name = "main")
vertex_main :: proc(
	a_position:   [3]f32 @ 0,
	a_normal:     [3]f32 @ 1,
	a_tex_coords: [2]f32 @ 2,
) -> (
	v_position:        [3]f32 @ 0,
	v_normal:          [3]f32 @ 1,
	v_tex_coords:      [2]f32 @ 2,
	v_shadow_position: [3]f32 @ 3,
) {
	v_position   = (vs_constants.model * [4]f32{a_position, 1}).xyz
	v_normal     = vs_constants.normal_matrix * a_normal
	v_tex_coords = a_tex_coords

	when !SHADOW_PASS {
		shadow_position  := shadow_uniforms.shadow_matrix * [4]f32{v_position, 1}
		v_shadow_position = (shadow_position.xyz / shadow_position.w) * 0.5 + 0.5
	}

	$Position = vs_constants.proj * vs_constants.view * [4]f32{v_position, 1}
	return
}

@(binding = Binding_Location.Image)
img: image[2][2]f32

@(binding = Binding_Location.Some_Buffer)
some_buffer: []struct {
	a, b: [4]f32,
}

/* FRAGMENT SHADER */

when SHADOW_PASS {
	@(fragment_shader, link_name = "main")
	fragment_main :: proc(
		v_position:        [3]f32 @ 0,
		v_normal:          [3]f32 @ 1,
		v_tex_coords:      [2]f32 @ 2,
		v_shadow_position: [3]f32 @ 3,
	) {
		
	}
} else {
	@(binding = Binding_Location.Texture)
	texture:       sampler[2][3]f32
	@(binding = Binding_Location.Depth_Texture)
	depth_texture: sampler[2]f32

	shadow_sample_bilinear :: proc(tex: sampler[2]f32, coords: [2]f32, current_depth, bias: f32) -> f32 {
		tex_size     := ([2]f32)(texture_size(tex))
		inv_tex_size := 1 / tex_size

		texel_pos := coords * tex_size
		base      := floor(texel_pos)
		f         := fract(texel_pos)

		base_uv := base * inv_tex_size

		uv00 := base_uv
		uv10 := base_uv + [2]f32{ inv_tex_size.x, 0.0, }
		uv01 := base_uv + [2]f32{ 0.0, inv_tex_size.y, }
		uv11 := base_uv + inv_tex_size

		w00 := (1.0 - f.x) * (1.0 - f.y)
		w10 := f.x         * (1.0 - f.y)
		w01 := (1.0 - f.x) * f.y
		w11 := f.x         * f.y

		d00 := tex[uv00] * 0.5 + 0.5
		d10 := tex[uv10] * 0.5 + 0.5
		d01 := tex[uv01] * 0.5 + 0.5
		d11 := tex[uv11] * 0.5 + 0.5

		shadow := 0.0
		shadow += ((current_depth - bias) > d00 ? 1 : 0) * w00
		shadow += ((current_depth - bias) > d10 ? 1 : 0) * w10
		shadow += ((current_depth - bias) > d01 ? 1 : 0) * w01
		shadow += ((current_depth - bias) > d11 ? 1 : 0) * w11

		return shadow
	}

	aces_approx :: proc(v: [3]f32) -> [3]f32 {
	    v := v * 0.6
		a := 2.51
		b := 0.03
		c := 2.43
		d := 0.59
		e := 0.14
	    return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0, 1)
	}

	@(fragment_shader, link_name = "main")
	fragment_main :: proc(
		v_position:        [3]f32 @ 0,
		v_normal:          [3]f32 @ 1,
		v_tex_coords:      [2]f32 @ 2,
		v_shadow_position: [3]f32 @ 3,
	) -> (
		f_color: [3]f32 @ 0,
	) {
		b := some_buffer[69]

		img[0] = 1
		texel := img[0]

		v_normal := normalize(v_normal)

		BIAS :: 0.001
		shadow: f32
		if v_shadow_position.x >= 0 && v_shadow_position.x <= 1 && v_shadow_position.y >= 0 && v_shadow_position.y <= 1 {
			when false {
				d := depth_texture[v_shadow_position.xy] * 0.5 + 0.5
				if (v_shadow_position.z - BIAS > d) {
					shadow = 1
				}
	    	} else {
				shadow = shadow_sample_bilinear(depth_texture, v_shadow_position.xy, v_shadow_position.z, BIAS)
	    	}
		}

		Some_Enum :: enum {
	
		}

		f: f32
		f = f % 10

	 	Some_Bit_Set :: bit_set[Some_Enum; u32]

	 	bits: Some_Bit_Set

		a: [4]f32 = { aces_approx(f_color.rgb), 0, }

		lighting := clamp(dot(v_normal, shadow_uniforms.light_direction), 0, 1)
		f_color   = (0.2 + 0.8 * lighting * f32(1 - shadow)) * texture[v_tex_coords]
		return aces_approx(f_color)
	}
}
